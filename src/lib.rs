#![cfg_attr(docsrs, feature(doc_auto_cfg))]
//! Computes isorings and contour polygons by applying
//! [marching squares](https://en.wikipedia.org/wiki/Marching_squares)
//! to a rectangular array of numeric values.
//!
//! Use the [`ContourBuilder`] to compute for a given set of values and thresholds:
//! - isolines, as a Vec of [`Line`],
//! - contour polygons, as a Vec of [`Contour`],
//! - isobands, as a Vec of [`Band`].
//!
//! The [`contour_rings`] function is a convenience function to compute ring (isoline) coordinates
//! for a single threshold.
//!
//! While contour polygons ([`Contour`]) enclose all the values above a given threshold,
//! isobands ([`Band`]) are polygons that enclose all the values between two thresholds.
//!
//! The core of the algorithm is ported from [d3-contour](https://github.com/d3/d3-contour/).
//!
//! #### Example:
#![cfg_attr(feature = "geojson", doc = "```")]
#![cfg_attr(not(feature = "geojson"), doc = "```ignore")]
//! # use contour::ContourBuilder;
//! let c = ContourBuilder::new(10, 10, false); // x dim., y dim., smoothing
//! let res = c.contours(&vec![
//!     0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
//!     0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
//!     0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
//!     0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
//!     0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
//!     0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
//!     0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
//!     0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
//!     0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
//!     0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
//! ], &[0.5]).unwrap(); // values, thresholds
//!
//! let output = serde_json::json!({
//!   "type": "Feature",
//!   "geometry": {
//!     "type": "MultiPolygon",
//!     "coordinates": [[[
//!       [6., 7.5], [6., 6.5], [6., 5.5], [6., 4.5],
//!       [6., 3.5], [5.5, 3.], [4.5, 3.], [3.5, 3.],
//!       [3., 3.5], [3., 4.5], [3., 5.5], [3., 6.5],
//!       [3., 7.5], [3.5, 8.], [4.5, 8.], [5.5, 8.],
//!       [6., 7.5]
//!     ]]],
//!   },
//!   "properties": {"threshold": 0.5},
//! });
//!
//! assert_eq!(res[0].to_geojson().unwrap(), std::convert::TryFrom::try_from(output).unwrap());
//! ```
//!
//! [`contour_rings`]: fn.contour_rings.html
//! [`ContourBuilder`]: struct.ContourBuilder.html

mod area;
mod band;
mod contour;
mod contourbuilder;
mod error;
mod isoringbuilder;
mod line;

pub trait GridValue: PartialOrd + Copy + Num + NumCast {}
impl<T> GridValue for T where T: PartialOrd + Copy + Num + NumCast {}

#[cfg(feature = "f32")]
pub type Float = f32;
#[cfg(not(feature = "f32"))]
pub type Float = f64;

pub type Pt = geo_types::Coord<Float>;
pub type Ring = Vec<Pt>;

pub use crate::{
    band::Band,
    contour::Contour,
    contourbuilder::ContourBuilder,
    error::{Error, ErrorKind, Result},
    isoringbuilder::contour_rings,
    line::Line,
};
use num_traits::{Num, NumCast};

#[cfg(test)]
mod tests {
    use crate::{ContourBuilder, Float};
    use geo_types::{line_string, polygon, MultiLineString, MultiPolygon};

    #[test]
    fn test_empty_polygons() {
        let c = ContourBuilder::new(10, 10, true);
        #[rustfmt::skip]
        let res = c.contours(&[
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
        ], &[0.5]).unwrap();
        assert!(res[0].geometry().0.is_empty());
    }

    #[test]
    fn test_empty_isoline() {
        let c = ContourBuilder::new(10, 10, true);
        #[rustfmt::skip]
            let res = c.lines(&[
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
        ], &[0.5]).unwrap();
        assert!(res[0].geometry().0.is_empty());
    }

    #[test]
    fn test_simple_polygon() {
        let c = ContourBuilder::new(10, 10, true);
        #[rustfmt::skip]
        let res = c.contours(&[
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
        ], &[0.5]).unwrap();
        assert_eq!(
            res[0].geometry(),
            &MultiPolygon::<Float>(vec![polygon![
                (x: 6.,  y: 7.5),
                (x: 6.,  y: 6.5),
                (x: 6.,  y: 5.5),
                (x: 6.,  y: 4.5),
                (x: 6.,  y: 3.5),
                (x: 5.5, y:  3.),
                (x: 4.5, y:  3.),
                (x: 3.5, y:  3.),
                (x: 3.,  y: 3.5),
                (x: 3.,  y: 4.5),
                (x: 3.,  y: 5.5),
                (x: 3.,  y: 6.5),
                (x: 3.,  y: 7.5),
                (x: 3.5, y:  8.),
                (x: 4.5, y:  8.),
                (x: 5.5, y:  8.),
                (x: 6.,  y: 7.5)
            ]])
        );
    }

    #[test]
    fn test_simple_isoline() {
        let c = ContourBuilder::new(10, 10, true);
        #[rustfmt::skip]
            let res = c.lines(&[
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
        ], &[0.5]).unwrap();
        assert_eq!(
            res[0].geometry(),
            &MultiLineString::<Float>(vec![line_string![
                (x: 6.,  y: 7.5),
                (x: 6.,  y: 6.5),
                (x: 6.,  y: 5.5),
                (x: 6.,  y: 4.5),
                (x: 6.,  y: 3.5),
                (x: 5.5, y:  3.),
                (x: 4.5, y:  3.),
                (x: 3.5, y:  3.),
                (x: 3.,  y: 3.5),
                (x: 3.,  y: 4.5),
                (x: 3.,  y: 5.5),
                (x: 3.,  y: 6.5),
                (x: 3.,  y: 7.5),
                (x: 3.5, y:  8.),
                (x: 4.5, y:  8.),
                (x: 5.5, y:  8.),
                (x: 6.,  y: 7.5)
            ]])
        );
    }

    #[test]
    fn test_polygon_with_hole() {
        let c = ContourBuilder::new(10, 10, true);
        #[rustfmt::skip]
        let res = c.contours(&[
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
            0., 0., 0., 1., 0., 1., 0., 0., 0., 0.,
            0., 0., 0., 1., 0., 1., 0., 0., 0., 0.,
            0., 0., 0., 1., 0., 1., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
        ], &[0.5]).unwrap();
        assert_eq!(
            res[0].geometry(),
            &MultiPolygon::<Float>(vec![polygon! {
                exterior: [
                    (x: 6., y: 7.5),
                    (x: 6., y: 6.5),
                    (x: 6., y: 5.5),
                    (x: 6., y: 4.5),
                    (x: 6., y: 3.5),
                    (x: 5.5,y:  3.),
                    (x: 4.5,y:  3.),
                    (x: 3.5,y:  3.),
                    (x: 3., y: 3.5),
                    (x: 3., y: 4.5),
                    (x: 3., y: 5.5),
                    (x: 3., y: 6.5),
                    (x: 3., y: 7.5),
                    (x: 3.5,y:  8.),
                    (x: 4.5,y:  8.),
                    (x: 5.5,y:  8.),
                    (x: 6., y: 7.5),
                ],
                interiors: [[
                    (x: 4.5,y:  7.),
                    (x: 4., y: 6.5),
                    (x: 4., y: 5.5),
                    (x: 4., y: 4.5),
                    (x: 4.5,y:  4.),
                    (x: 5., y: 4.5),
                    (x: 5., y: 5.5),
                    (x: 5., y: 6.5),
                    (x: 4.5,y:  7.),
                ]]
            }])
        );
    }

    #[test]
    fn test_multipolygon() {
        let c = ContourBuilder::new(10, 10, true);
        #[rustfmt::skip]
        let res = c.contours(&[
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 0., 1., 0., 0., 0.,
            0., 0., 0., 1., 1., 0., 1., 0., 0., 0.,
            0., 0., 0., 1., 1., 0., 1., 0., 0., 0.,
            0., 0., 0., 1., 1., 0., 1., 0., 0., 0.,
            0., 0., 0., 1., 1., 0., 1., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
        ], &[0.5]).unwrap();
        assert_eq!(
            res[0].geometry(),
            &MultiPolygon::<Float>(vec![
                polygon![
                    (x: 5., y: 7.5),
                    (x: 5., y: 6.5),
                    (x: 5., y: 5.5),
                    (x: 5., y: 4.5),
                    (x: 5., y: 3.5),
                    (x: 4.5,y:  3.),
                    (x: 3.5,y:  3.),
                    (x: 3., y: 3.5),
                    (x: 3., y: 4.5),
                    (x: 3., y: 5.5),
                    (x: 3., y: 6.5),
                    (x: 3., y: 7.5),
                    (x: 3.5,y:  8.),
                    (x: 4.5,y:  8.),
                    (x: 5., y: 7.5),
                ],
                polygon![
                    (x: 7., y: 7.5),
                    (x: 7., y: 6.5),
                    (x: 7., y: 5.5),
                    (x: 7., y: 4.5),
                    (x: 7., y: 3.5),
                    (x: 6.5,y:  3.),
                    (x: 6., y: 3.5),
                    (x: 6., y: 4.5),
                    (x: 6., y: 5.5),
                    (x: 6., y: 6.5),
                    (x: 6., y: 7.5),
                    (x: 6.5,y:  8.),
                    (x: 7., y: 7.5),
                ],
            ])
        );
    }

    #[test]
    fn test_multipolygon_with_hole() {
        let c = ContourBuilder::new(10, 10, true);
        #[rustfmt::skip]
        let res = c.contours(&[
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 1., 1., 1., 0., 1., 1., 1., 0., 0.,
            0., 1., 0., 1., 0., 1., 0., 1., 0., 0.,
            0., 1., 1., 1., 0., 1., 1., 1., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
        ], &[0.5]).unwrap();
        assert_eq!(
            res[0].geometry(),
            &MultiPolygon::<Float>(vec![
                polygon! {
                     exterior: [
                             (x: 4., y: 5.5),
                             (x: 4., y: 4.5),
                             (x: 4., y: 3.5),
                             (x: 3.5,y:  3.),
                             (x: 2.5,y:  3.),
                             (x: 1.5,y:  3.),
                             (x: 1., y: 3.5),
                             (x: 1., y: 4.5),
                             (x: 1., y: 5.5),
                             (x: 1.5,y:  6.),
                             (x: 2.5,y:  6.),
                             (x: 3.5,y:  6.),
                             (x: 4., y: 5.5),
                     ],
                     interiors: [[
                         (x: 2.5, y:  5.),
                         (x: 2.,  y: 4.5),
                         (x: 2.5, y:  4.),
                         (x: 3.,  y: 4.5),
                         (x: 2.5, y:  5.),
                     ]]
                },
                polygon! {
                    exterior: [
                        (x: 8., y: 5.5),
                        (x: 8., y: 4.5),
                        (x: 8., y: 3.5),
                        (x: 7.5,y:  3.),
                        (x: 6.5,y:  3.),
                        (x: 5.5,y:  3.),
                        (x: 5., y: 3.5),
                        (x: 5., y: 4.5),
                        (x: 5., y: 5.5),
                        (x: 5.5,y:  6.),
                        (x: 6.5,y:  6.),
                        (x: 7.5,y:  6.),
                        (x: 8., y: 5.5),
                    ],
                    interiors: [[
                        (x: 6.5, y: 5.),
                        (x: 6.,  y:4.5),
                        (x: 6.5, y: 4.),
                        (x: 7.,  y:4.5),
                        (x: 6.5, y: 5.),
                    ]],
                },
            ])
        );
    }

    #[test]
    fn test_simple_polygon_no_smoothing() {
        let c = ContourBuilder::new(10, 10, false);
        #[rustfmt::skip]
        let res = c.contours(&[
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 2., 1., 2., 0., 0., 0., 0.,
            0., 0., 0., 2., 2., 2., 0., 0., 0., 0.,
            0., 0., 0., 1., 2., 1., 0., 0., 0., 0.,
            0., 0., 0., 2., 2., 2., 0., 0., 0., 0.,
            0., 0., 0., 2., 1., 2., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
        ], &[0.5]).unwrap();
        assert_eq!(
            res[0].geometry(),
            &MultiPolygon::<Float>(vec![polygon![
                            (x: 6.,  y: 7.5),
                            (x: 6.,  y: 6.5),
                            (x: 6.,  y: 5.5),
                            (x: 6.,  y: 4.5),
                            (x: 6.,  y: 3.5),
                            (x: 5.5, y:  3.),
                            (x: 4.5, y:  3.),
                            (x: 3.5, y:  3.),
                            (x: 3.,  y: 3.5),
                            (x: 3.,  y: 4.5),
                            (x: 3.,  y: 5.5),
                            (x: 3.,  y: 6.5),
                            (x: 3.,  y: 7.5),
                            (x: 3.5, y:  8.),
                            (x: 4.5, y:  8.),
                            (x: 5.5, y:  8.),
                            (x: 6.,  y: 7.5),

            ]])
        );
    }

    #[test]
    fn test_multiple_thresholds() {
        let c = ContourBuilder::new(10, 10, true);
        #[rustfmt::skip]
        let res = c.contours(&[
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 1., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 1., 0., 0., 0.,
            0., 0., 0., 1., 2., 2., 1., 0., 0., 0.,
            0., 0., 0., 1., 1., 2., 1., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 1., 0., 0., 0.,
            0., 0., 0., 1., 1., 1., 1., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
        ], &[0.5, 1.5]).unwrap();
        assert_eq!(
            res[0].geometry(),
            &MultiPolygon::<Float>(vec![polygon![
            (x: 7., y: 8.5),
            (x: 7., y: 7.5),
            (x: 7., y: 6.5),
            (x: 7., y: 5.5),
            (x: 7., y: 4.5),
            (x: 7., y: 3.5),
            (x: 6.5,y:  3.),
            (x: 5.5,y:  3.),
            (x: 4.5,y:  3.),
            (x: 3.5,y:  3.),
            (x: 3., y: 3.5),
            (x: 3., y: 4.5),
            (x: 3., y: 5.5),
            (x: 3., y: 6.5),
            (x: 3., y: 7.5),
            (x: 3., y: 8.5),
            (x: 3.5,y:  9.),
            (x: 4.5,y:  9.),
            (x: 5.5,y:  9.),
            (x: 6.5,y:  9.),
            (x: 7., y: 8.5)
                ]])
        );
        assert_eq!(
            res[1].geometry(),
            &MultiPolygon::<Float>(vec![polygon![
                (x: 6.,  y: 6.5),
                (x: 6.,  y: 5.5),
                (x: 5.5, y:  5.),
                (x: 4.5, y:  5.),
                (x: 4.,  y: 5.5),
                (x: 4.5, y:  6.),
                (x: 5.,  y: 6.5),
                (x: 5.5, y:  7.),
                (x: 6.,  y: 6.5)
            ]])
        );
    }

    #[cfg(not(feature = "f32"))]
    #[test]
    fn test_issue18() {
        let data_str = include_str!("../tests/fixtures/issue18.json");
        let raw_data: serde_json::Value = serde_json::from_str(data_str).unwrap();
        let matrix: Vec<Float> = raw_data["data"]
            .as_array()
            .unwrap()
            .iter()
            .map(|x| x.as_f64().unwrap() as Float)
            .collect();
        let h = raw_data["height"].as_u64().unwrap() as usize;
        let w = raw_data["width"].as_u64().unwrap() as usize;

        let c = ContourBuilder::new(w, h, true);
        let res = c.contours(&matrix, &[10.]).unwrap();
        assert_eq!(
            res[0].geometry(),
            &MultiPolygon::<Float>(vec![
                polygon![
                    (x: 5.093049464469837, y: 2.5),
                    (x: 4.5, y: 1.675604779947537),
                    (x: 4.041491617923191, y: 2.5),
                    (x: 4.5, y: 3.0939939099086486),
                    (x: 5.093049464469837, y: 2.5),
                ],
                polygon![
                    (x: 3.2866555248441216, y: 3.5),
                    (x: 2.5380369570434365, y: 2.5),
                    (x: 2.810018648476255, y: 1.5),
                    (x: 2.5, y: 0.7099240221367358),
                    (x: 2.102376081825299, y: 1.5),
                    (x: 1.5, y: 2.2930927322449044),
                    (x: 0.9128140626438015, y: 1.5),
                    (x: 1.5, y: 0.7886423607239752),
                    (x: 2.1982064997527755, y: 0.5),
                    (x: 1.5, y: 0.0),
                    (x: 0.5, y: 0.0),
                    (x: 0.0, y: 0.5),
                    (x: 0.0, y: 1.5),
                    (x: 0.0, y: 2.5),
                    (x: 0.5, y: 3.3582089552233354),
                    (x: 1.5, y: 2.708014829934868),
                    (x: 2.108384, y: 3.5),
                    (x: 2.5, y: 4.408234071765186),
                    (x: 3.2866555248441216, y: 3.5),
                ],
                polygon![
                    (x: 6.441781292984862, y: 3.5),
                    (x: 5.5, y: 2.959587986897662),
                    (x: 4.958615849921951, y: 3.5),
                    (x: 5.5, y: 3.8767591586303354),
                    (x: 6.441781292984862, y: 3.5),
                ],
                polygon![
                    (x: 4.0457991530192805, y: 4.5),
                    (x: 3.5, y: 3.7647997446944315),
                    (x: 2.618308376788021, y: 4.5),
                    (x: 3.5, y: 5.140019447145437),
                    (x: 4.0457991530192805, y: 4.5),
                ],
                polygon![
                    (x: 7.016556897182495, y: 4.5),
                    (x: 6.5, y: 3.6303611303611305),
                    (x: 6.300452312802572, y: 4.5),
                    (x: 6.5, y: 4.727784276551992),
                    (x: 7.016556897182495, y: 4.5),
                ],
                polygon![
                    (x: 3.1676925049689437, y: 5.5),
                    (x: 2.5, y: 4.606132784000669),
                    (x: 2.0164254986312082, y: 4.5),
                    (x: 1.5, y: 4.435054715357187),
                    (x: 0.5, y: 3.5148494368248206),
                    (x: 0.0, y: 4.5),
                    (x: 0.0, y: 5.5),
                    (x: 0.5, y: 6.231487086359968),
                    (x: 1.5, y: 6.137720033528919),
                    (x: 2.5, y: 5.946904838536682),
                    (x: 3.1676925049689437, y: 5.5),
                ],
                polygon![
                    (x: 5.084253149370173, y: 8.5),
                    (x: 5.5, y: 8.109086806926463),
                    (x: 6.223857085400153, y: 7.5),
                    (x: 6.5, y: 7.140249759846301),
                    (x: 7.011048375853896, y: 6.5),
                    (x: 6.5, y: 6.223083605597608),
                    (x: 5.5, y: 5.6994222282881175),
                    (x: 4.5, y: 6.254883716200413),
                    (x: 4.150007260055157, y: 6.5),
                    (x: 3.5, y: 7.222661673070077),
                    (x: 3.1732349360925136, y: 7.5),
                    (x: 3.5, y: 8.060357480674517),
                    (x: 3.908975059166165, y: 8.5),
                    (x: 4.5, y: 9.177341957020609),
                    (x: 5.084253149370173, y: 8.5),
                ],
                polygon![
                    (x: 2.4412640476419276, y: 9.5),
                    (x: 1.5, y: 9.30005100999793),
                    (x: 1.320828800497289, y: 9.5),
                    (x: 1.5, y: 10.0),
                    (x: 2.4412640476419276, y: 9.5),
                ],
                polygon![
                    (x: 10.0, y: 9.5),
                    (x: 10.0, y: 8.5),
                    (x: 10.0, y: 7.5),
                    (x: 10.0, y: 6.5),
                    (x: 10.0, y: 5.5),
                    (x: 10.0, y: 4.5),
                    (x: 10.0, y: 3.5),
                    (x: 10.0, y: 2.5),
                    (x: 10.0, y: 1.5),
                    (x: 10.0, y: 0.5),
                    (x: 9.5, y: 0.0),
                    (x: 8.5, y: 0.0),
                    (x: 7.5, y: 0.0),
                    (x: 6.5, y: 0.0),
                    (x: 5.5, y: 0.0),
                    (x: 4.5, y: 0.0),
                    (x: 3.5, y: 0.0),
                    (x: 2.663832019716454, y: 0.5),
                    (x: 3.5, y: 0.8786157823790688),
                    (x: 4.5, y: 1.3957432081675032),
                    (x: 4.74461210542345, y: 1.5),
                    (x: 5.5, y: 1.98943399535271),
                    (x: 6.017704327724515, y: 2.5),
                    (x: 6.5, y: 3.427621734855286),
                    (x: 6.616189691853682, y: 3.5),
                    (x: 7.5, y: 4.0492152848856175),
                    (x: 7.6640591047371185, y: 4.5),
                    (x: 7.765869728675749, y: 5.5),
                    (x: 8.019380992928879, y: 6.5),
                    (x: 8.5, y: 6.935535276948297),
                    (x: 8.930593233352143, y: 7.5),
                    (x: 8.5, y: 7.910325821871075),
                    (x: 7.717229434426615, y: 8.5),
                    (x: 7.5, y: 8.658415374082265),
                    (x: 6.5, y: 8.666753585397572),
                    (x: 5.5, y: 8.792345981060047),
                    (x: 4.7166421517126125, y: 9.5),
                    (x: 5.5, y: 10.0),
                    (x: 6.5, y: 10.0),
                    (x: 7.5, y: 10.0),
                    (x: 8.5, y: 10.0),
                    (x: 9.5, y: 10.0),
                    (x: 10.0, y: 9.5),
                ],
            ])
        );
    }

    #[test]
    fn test_multipolygon_with_x_y_steps() {
        let c = ContourBuilder::new(10, 10, true)
            .x_step(2.0)
            .y_step(2.0)
            .x_origin(100.0)
            .y_origin(200.0);
        #[rustfmt::skip]
        let res = c.contours(&[
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 1., 1., 0., 1., 0., 0., 0.,
            0., 0., 0., 1., 1., 0., 1., 0., 0., 0.,
            0., 0., 0., 1., 1., 0., 1., 0., 0., 0.,
            0., 0., 0., 1., 1., 0., 1., 0., 0., 0.,
            0., 0., 0., 1., 1., 0., 1., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
        ], &[0.5]).unwrap();

        assert_eq!(
            res[0].geometry(),
            &MultiPolygon::<Float>(vec![
                polygon![
                    (x: 110.0, y: 215.0),
                    (x: 110.0, y: 213.0),
                    (x: 110.0, y: 211.0),
                    (x: 110.0, y: 209.0),
                    (x: 110.0, y: 207.0),
                    (x: 109.0, y: 206.0),
                    (x: 107.0, y: 206.0),
                    (x: 106.0, y: 207.0),
                    (x: 106.0, y: 209.0),
                    (x: 106.0, y: 211.0),
                    (x: 106.0, y: 213.0),
                    (x: 106.0, y: 215.0),
                    (x: 107.0, y: 216.0),
                    (x: 109.0, y: 216.0),
                    (x: 110.0, y: 215.0)
                ],
                polygon![
                    (x: 114.0, y: 215.0),
                    (x: 114.0, y: 213.0),
                    (x: 114.0, y: 211.0),
                    (x: 114.0, y: 209.0),
                    (x: 114.0, y: 207.0),
                    (x: 113.0, y: 206.0),
                    (x: 112.0, y: 207.0),
                    (x: 112.0, y: 209.0),
                    (x: 112.0, y: 211.0),
                    (x: 112.0, y: 213.0),
                    (x: 112.0, y: 215.0),
                    (x: 113.0, y: 216.0),
                    (x: 114.0, y: 215.0)
                ]
            ])
        );
    }

    #[cfg(feature = "geojson")]
    #[test]
    fn test_simple_polygon_no_smoothing_geojson() {
        let c = ContourBuilder::new(10, 10, false);
        #[rustfmt::skip]
        let res = c.contours(&[
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 2., 1., 2., 0., 0., 0., 0.,
            0., 0., 0., 2., 2., 2., 0., 0., 0., 0.,
            0., 0., 0., 1., 2., 1., 0., 0., 0., 0.,
            0., 0., 0., 2., 2., 2., 0., 0., 0., 0.,
            0., 0., 0., 2., 1., 2., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
        ], &[0.5]).unwrap();
        match res[0].to_geojson().unwrap().geometry.unwrap().value {
            geojson::Value::MultiPolygon(p) => {
                assert_eq!(
                    p,
                    vec![vec![vec![
                        vec![6., 7.5],
                        vec![6., 6.5],
                        vec![6., 5.5],
                        vec![6., 4.5],
                        vec![6., 3.5],
                        vec![5.5, 3.],
                        vec![4.5, 3.],
                        vec![3.5, 3.],
                        vec![3., 3.5],
                        vec![3., 4.5],
                        vec![3., 5.5],
                        vec![3., 6.5],
                        vec![3., 7.5],
                        vec![3.5, 8.],
                        vec![4.5, 8.],
                        vec![5.5, 8.],
                        vec![6., 7.5],
                    ]]]
                );
            }
            _ => panic!(""),
        };
    }
}
